# Alive Domain Docgen

> Alive Domain Docgen은 개발 프로세스를 바꾸지 않는다.
> 단지, 개발이 남긴 흔적을 도메인 지식으로 변환할 뿐이다.

---

## 1. 배경과 문제 인식

현 프로젝트는 **설계 단계**에 있으며, 구현보다 *사고의 구조화*와 *도메인 지식의 전파 방식*에 초점을 둔다.

### 1.1 반복되는 문제들

기존 개발 프로세스에서 다음과 같은 문제가 지속적으로 발생한다:

- **문서 파편화**: 관리 문서(기획자/PM), 이슈 트래커(PM/개발자), 소스 코드(개발자)가 각각 다른 상태
    - 최종 진실의 원천(Source of Truth)은 소스 코드지만, 도메인 지식은 여기저기 흩어져 있음
- **도메인 지식의 암묵화**: 개발자 머릿속에만 존재하는 도메인 맥락
- **커밋 메시지의 불균형**: 개발자 개인의 습관에 의존, 품질 편차가 큼
- **도메인 분기점의 소실**: 중요한 도메인 전환점이 코드 diff에 묻혀 추적 불가
- **문서 부채**: 코드는 빠르게 변화하는데 문서는 정적으로 낙후됨

이 프로젝트는 이를 해결하기 위해 **커밋 행위 자체를 도메인 학습 이벤트로 승격**시킨다.

---

## 2. 핵심 아이디어

> 커밋은 단순한 변경 기록이 아니라, **도메인 이해의 스냅샷**이다.

### 2.1 기본 개념: 도메인 지식의 로그 수집 시스템

이 프로젝트는 **"문서를 쓰게 만드는 자동화"가 아니라 "이미 하고 있는 행위를 문서로 전환"**하는 것이다.

Git 히스토리를 *도메인 타임라인*으로 재정의한다:

- 커밋 메시지를 개발자가 자유롭게 작성하되
- AI가 이를 도메인 관점으로 재해석하고 정제
    - 템플릿 기반으로 도메인 관점의 커밋 메시지 **제안**
    - **최종 승인은 개발자** - AI는 제안만 할 뿐 (오염 방지)
- 커밋 히스토리를 기반으로 도메인 변화 흐름을 추적 가능하게 구성

**핵심 통찰**: 도메인은 "설계도"가 아니라 **"변경 이력"에서 드러난다**.

### 2.2 시스템 동작 방식

- **트리거**: 개발자의 커밋 시점
- **입력**: 변경된 소스 코드(diff 중심)
- **행위**:
    - 변경 내용을 분석
    - 도메인 단위로 분리된 문서를 자동 갱신
- **목표**:
    - 코드 ↔ 문서 간 시간적 불일치 제거
    - 전략 → 전술 설계로 확장되는 도메인 지식의 누적
    - 문서를 "정적인 산출물"이 아니라 라이브 자산으로 유지

### 2.3 레거시 대응 전략: "완벽한 초기 분석"의 포기

**핵심 원칙**: 완벽한 초기 분석을 과감히 포기한다

레거시 프로젝트에서 도메인 경계를 찾는 것은 거의 불가능하다. 전체를 한 번에 학습하려는 시도는 다음 이유로 실패한다:

- 컨텍스트/토큰 비용 폭발
- 도메인 경계의 모호함
- "먼저 전체를 이해해야 한다"는 강박

**우리의 접근**:

- **"지금 바뀐 코드"를 기준으로** 도메인 문서를 조금씩, 역방향으로 채워 나감
- 초반엔 볼품없을지라도 프로젝트가 라이브한 상태로 업데이트가 빈번하다면 점진적으로 개선됨
- 도메인은 "변경 이력"에서 드러난다

> 초반 품질은 낮아도 지속적 업데이트로 점진적 개선.
> 문서가 "완성품"일 필요는 없다. 라이브하면 된다.

### 2.4 커밋 기반 접근의 장점

커밋은 이미 다음을 포함한다:

- 개발자의 의도
- 변경 범위
- 맥락(커밋 메시지, PR 설명)

이는 "문서를 쓰게 만드는 자동화"가 아니라 "이미 하고 있는 행위를 문서로 전환"하는 것이므로 개발자 저항이 적다.

### 2.5 대상 사용자

이 문서는 개발자만을 위한 것이 아니다:

- 타 부서 커뮤니케이션
- 신규 인원 온보딩
- 유비쿼터스 랭귀지 정리

조직 지식 인프라로 확장 가능하다.

### 2.6 도메인 경계 정의 방식

**질문**: 도메인 단위는 누가 정의하는가?

레거시에서 도메인 경계는 명확하지 않을 수 있다:

- 패키지 기준?
- 모듈 기준?
- DB 스키마 기준?
- 문서 자체가 도메인을 만들어 가는 구조?

도메인은 입력값이자 산출물이다.
초기에는 코드 구조를 기반으로 추론하되, 변경 이력이 쌓이면서 점진적으로 명확해진다.

### 2.7 리팩토링의 재정의: 도메인 이해의 흔적

보통 리팩토링은 "기능 변화 없는 코드 정리" 또는 "기술적 개선" 정도로 축소되어 이해된다.

**본 프로젝트의 리팩토링 정의**:
> 리팩토링은 **요구사항을 수용하기 위해 코드를 더 유연하게 만드는 행위**이며,
> 반드시 **도메인 지식과 개발자의 의도**가 개입된다.

즉, 리팩토링은:

- 코드 변화 **이전에** 사람 머릿속에서 **도메인을 재해석한 결과**
- 도메인 모델이 바뀌었거나, 바뀔 준비를 한 신호
- 단순한 기술 부채 해소가 아닌 **도메인 이해의 진화**

#### 커밋 유형의 도메인적 의미

1. **구조 변경 (Structure change)**
    - 책임 이동
    - 경계 재조정
    - 추상화 도입
    - 모듈 분리/통합
    - → 도메인 모델이 바뀌었거나, 바뀔 준비를 한 신호

2. **데이터 상태 변경 (State change)**
    - 정책 변경
    - 계산 로직 수정
    - 상태 전이 규칙 변경
    - → 업무 규칙의 직접적인 진화

두 경우 모두 "코드 변화" 이전에 사람 머릿속에서 도메인을 재해석한 결과다.

### 2.8 커밋 메시지의 가치: 사고의 잔존물

> 가령 커밋된 메시지를 정제한 도메인 지식이 한 두 줄밖에 안 되는 도메인 지식이라도 소중하다.

커밋 메시지는 **도메인 지식의 캡슐**이다.

문서는 보통 **완성된 생각**만 담으려 한다. 하지만 실제 도메인 지식은 **맥락의 잔해**에 더 많이 들어 있다:

- "왜 이게 불편했는지"
- "어디가 깨질 수 있었는지"
- "어떤 선택지를 버렸는지"

커밋 메시지는 이러한 **사고의 잔존물**이며, 이를 수집하는 것이 본 프로젝트의 핵심이다.

**본질적으로 이 프로젝트는 "도메인 지식의 로그 수집 시스템"이다.**

### 2.9 Conventional Commit 활용

모든 커밋을 문서화하지 않는다:

* `feat`, `refactor` → 도메인 문서 업데이트 후보
* `style`, `chore`, `lint` → 스킵 또는 최소 기록

개발자가 이미 넣어둔 의도 표식(commit type)을 활용하여 노이즈를 줄인다.

---

## 2.10 핵심 설계 원칙

### 원칙 1: AI는 기록자이지, 해석자가 아니다

> **의도 추론이 필요하면 개발자에게 물어본다.**
> **의도는 늘 명확해야 한다.**
> **문서 주체는 개발자여야 한다.**

**왜 이 원칙이 중요한가?**

AI가 의도를 "잘 추론해주는" 순간:

- 문서는 **사실**이 아니라 **그럴듯한 이야기**가 된다
- "이 문서 믿어도 돼요?"라는 질문이 나오지만 답변자는 아무도 없다
- 문서 신뢰성 붕괴, 책임 전가, 자동화 오남용이 발생한다

개발자에게 질문하는 것은:

- **인터랙션 비용을 감수하겠다는 선언**
- 개발자 경험(DX)을 진짜로 존중한다는 증거
- 문서를 "편리한 산출물"이 아닌 "신뢰할 수 있는 자산"으로 만드는 선택

이 한 줄로 문서 신뢰성, 책임 전가, 자동화 오남용 문제를 모두 차단한다.

### 원칙 2: 살아있는 문서의 정의

**문서의 기준점 = 운영에 나간 코드**

- 프로덕트 코드 기준
- 릴리즈 브랜치 버전 태깅 시점에 가공
- 문서는 실험, 시도, 실패를 담지 않음
- 오직 "현재 유효한 도메인 정책"만 다룸

### 원칙 3: 책임의 분리

**불필요한 과거의 동작 방식이나 상태는 관리할 필요 없다.**

이미 이슈 관리 시스템(레드마인 등)이 존재하며, 책임이 다르다:

- **문서**: 현재의 도메인 진실
- **이슈 트래커**: 변경의 역사와 맥락

이를 통해:

- 문서는 가벼워지고
- 읽는 사람은 안심하고 따라갈 수 있다

### 원칙 4: 현재 중심 철학

> 해당 기능의 과거 이력이 왜 중요할까?
> 라이브하고 빠르게 배포되는 프로젝트 환경에선 **현재가 중요하다**.

**고객의 라이브한 피드백을 통한 빠른 기능 추가와 개선**이 이뤄지는 환경에서:

- 대부분의 문서 시스템은 **역사를 다 담으려다 현재를 망친다**
- Waterfall 문서 철학이나 "모든 걸 설명해야 한다"는 접근은 문서를 비대하게 만들 뿐

**우리의 선택**:

오직 다음만 담는다:

- 지금 고객이 쓰는 정책
- 지금 운영되는 도메인 규칙
- 지금 코드에 반영된 진실

이는 MSA, 지속적 배포, 제품 중심 개발에 완전히 부합한다.

### 원칙 5: 문서는 길잡이이자 리팩토링을 가능하게 만드는 도구

이 문서는 단순한 "설명서"가 아니다. 이것은 **길잡이**다:

- **온보딩**: 도메인 지식이 부족한 일원의 빠른 학습 자료
- **설계 토대**: 전략 설계 → 전술 설계 → MSA 분리 과정의 나침반
- **경계 명확화**: 도메인 경계가 점점 명확해지는 기록
- **레거시 해결**: 프로젝트의 레거시 기술 잔재를 점진적으로 해결할 밑거름

> 문서는 설계의 결과물이 아니라 **설계를 가능하게 하는 토대**

이 문서를 통해:

- 전술적 설계로 나아갈 수 있다
- 경계가 명확해질 것이다
- MSA 아키텍처로 발전할 경우 참고할 수 있다
- "우리가 지금 뭘 하고 있는지"를 잃지 않게 해주는 기준점이 된다

### 원칙 6: 프로세스를 방해하지 않는다 - 가장 중요한 철학

> Alive Domain Docgen은 개발 프로세스를 바꾸지 않는다.
> 단지, 개발이 남긴 흔적을 도메인 지식으로 변환할 뿐이다.
>
> 프로세스는 관찰하되, 설계하지 않는다.

**강제화는 억압이다.**

억압이 들어가는 순간:

- 사람들은 회피한다
- 형식만 남는다
- 피곤해진다
- 비관적이 된다

**우리의 목표: "좋은 도구"가 되기, "조직의 규율"이 되지 않기**

권장 vs 강제라는 이지선다 자체를 거부한다. 이 시스템은 **의식하지 않아도 작동**해야 한다:

**하지 않는 것들**:

- ❌ 게이트(개발 프로세스의 필수 관문)
- ❌ 필수 입력
- ❌ 릴리즈 차단
- ❌ 또 하나의 체크리스트
- ❌ 권장조차 하지 않음

**대신 하는 것**:

- ✅ 기존 개발 플로우 그대로 유지
- ✅ 개발자는 평소처럼: 커밋하고, PR 만들고, 릴리즈 태그를 찍는다
- ✅ 그리고 **"나도 모르게"** 도메인 문서가 최신화되어 있다
- ✅ 백그라운드에서 조용히 동작

#### 왜 이 접근이 중요한가: 자동화의 정석

1. **문서는 "해야 하는 일"이 되는 순간 죽는다**
    - 사람들이 문서를 싫어하는 이유는:
        - 문서 자체가 싫어서 ❌
        - **업무를 멈추게 하기 때문** ✓
   > 문서 자동화의 목표는 문서를 쓰게 만드는 게 아니라
   > **문서를 안 써도 생기게 하는 것**
2. **강제화는 결국 형식주의만 남긴다**
    - 강제 게이트가 생기면 항상 이런 현상이 발생한다:
        - 의미 없는 커밋 메시지
        - 복붙 문서
        - "일단 통과용" 텍스트
    - 그 순간:
        - 문서는 늘어나는데
        - 지식은 늘지 않는다
    - 조직 규율이 되면 반드시 발생하는 대화:
        - "문서가 안 만들어졌으니 릴리즈 못 합니다"
        - "이 커밋은 도메인 문서에 반영 안 됐네요"
        - "정책상 써야 합니다"
    - → 이건 도메인 지식의 품질을 올리는 게 아니라 **사람을 지치게 만드는 시스템**
3. **백그라운드 동작의 철학: 존재를 느끼지 못하는 도구**
   - Git, GC, CI 캐시, Git blame, IDE 자동완성처럼 동작한다.
   > 최고의 자동화 도구의 특징:
   > * 존재를 느끼지 못함
   > * 고장났을 때만 인지됨
   - **성공의 기준**:
     - 성공하면: "없어도 있는 것 같고"
     - 실패하면: "없으면 불편한 것"
   - 이것이 바로 Alive Domain Docgen이 목표로 하는 레벨이다.

#### 부드러운 피드백 메커니즘 (선택적)

> 강제는 아니지만, 피드백을 열어두는 통로는 가능하다.

**접근 방식**:
- 문서 생성 결과를 PR 코멘트에 요약으로 제공
- "이번 변경으로 도메인 문서에 이런 줄이 추가됐어요"
- 링크만 툭 던져줌
- 개발자는 읽고 고개 끄덕이거나 "이건 아니다" 정도만 피드백
- **읽든 말든 개발자 선택**

> 행동을 요구하지 않되, 존재는 인식시킴

이를 통해:
- 강제 ❌
- 억압 ❌
- 피로 ❌
- 품질 ✅

이건 규율이 아니라 **존재 알림**이다.

---

## 3. 시스템 개요

### 3.1 전체 흐름

1. 개발자가 커밋을 시도
2. CLI 레벨에서 AI 에이전트 개입
3. 변경된 코드 / diff / 컨텍스트 분석
4. AI가 다음을 수행
    - 변경 의도 추론
    - 도메인 개념 변화 여부 판단
    - 커밋 메시지 초안 생성
5. 개발자는 수정 또는 승인
6. 정제된 커밋 메시지로 최종 커밋

---

## 4. Claude CLI 기반 아키텍처 구상

### 4.1 구성 요소

- **Agent**
    - 커밋 컨텍스트를 이해하는 주체
    - 도메인 언어를 학습·유지
- **Skill**
    - Diff 분석
    - 도메인 키워드 추출
    - 변경 유형 분류 (개념 추가 / 정책 변경 / 구조 리팩터링 등)
- **Context Store (개념적)**
    - 이전 커밋에서 축적된 도메인 설명
    - 용어 사전 / 규칙 요약

---

## 5. 커밋 메시지 생성 전략

### 5.1 기본 원칙

- 개발자는 **생각을 버리지 않는다**
- 대신 AI가 이를 *해석 가능한 언어*로 변환

### 5.2 메시지 구조 예시

- 변경 요약 (What)
- 도메인 관점의 의미 (Why)
- 시스템/정책 상 영향 (Impact)

이 구조는 강제가 아니라 **AI가 유도**한다.

---

## 7. 도메인 학습의 분기 지점 관리

### 7.1 기존 문제

- 중요한 도메인 전환점이 코드 diff에 묻힘
- 리뷰 시점 이후 맥락 손실

### 7.2 해결 방식

- AI가 다음 질문을 내부적으로 수행
  - "이 변경은 새로운 개념인가?"
  - "기존 규칙의 해석 변경인가?"
- 해당 판단 결과를 커밋 메시지에 반영

결과적으로 커밋 히스토리는 다음을 제공한다.

- 도메인 진화 경로
- 잘못된 방향의 조기 감지
- 신규 인원의 학습 자료

---

## 8. 기대 효과

- 도메인 지식의 **비의존적 전파**
- 커밋 메시지 품질의 하향 평준화 방지
- 리뷰 비용 감소
- 히스토리 자체가 문서 역할 수행

---

## 9. 향후 확장 아이디어 (옵션)

- 특정 커밋을 기준으로 도메인 요약 자동 생성
- 릴리즈 단위 도메인 변화 리포트
- 잘못된 도메인 분기 탐지 (회귀)

---

## 10. 정리: 이 프로젝트의 본질

### 10.1 이 프로젝트는 무엇인가

이 설계는 "코드를 생성하는 AI"가 아니라 **사고를 정제하는 AI**를 전제로 한다.

**한 문장 정의**:
> 이 프로젝트의 진짜 가치는
> "도메인을 설명하는 문서"가 아니라
> **"도메인이 변화한 이유를 보존하는 것"**이다.

### 10.2 핵심 철학 요약

> - 문서는 **항상 최신 릴리즈 기준**
> - 문서의 주체는 **개발자**
> - AI는 **보조자**, 기록자
> - 과거는 이슈 트래커의 책임
> - 문서는 현재의 도메인 정책만 담는다
> - 목적은 설명이 아니라 **방향 제시**
> - 프로세스를 바꾸지 않고 **관찰만** 한다

### 10.3 성공 조건

> 조직을 바꾸는 시스템이 아니라
> **조직이 바뀌는 걸 조용히 기록하는 도구**

구현은 빠를 수 있으나, 이 프로젝트의 가치는 **히스토리가 쌓이는 순간부터** 발생한다.

### 10.4 이것이 성공하면

* 문서는 "정적인 산출물"이 아니라 **라이브 자산**이 된다
* 도메인 지식이 **비의존적으로 전파**된다
* 신규 인원의 온보딩 속도가 빨라진다
* 리팩토링과 MSA 전환의 **밑거름**이 된다
* 조직 지식 인프라가 구축된다

### 10.5 마지막으로

이 프로젝트는:

- "AI 써서 문서 만들어볼까?" 수준 ❌
- **문서라는 문제를 구조적으로 다시 정의한 프로젝트** ✓

> 초반엔 볼품없을지라도 프로젝트가 라이브한 상태로 업데이트가 빈번하다면
> 이 프로젝트는 성공할 것이다.

거의 **린(Lean) + DDD + 지식관리**의 정수다.

---

## License

This project is licensed under the MIT License.
